
\centerline{\textbf{ \LARGE Queue Level-3}}

\begin{questyle}
  \question  An implementation of a queue Q, using two stacks S1 and S2, is given below:  (GATE-2006)
    \lstinputlisting[language=Octave]{./queue_code/queue_01.c}
    Let n insert and m (\(<=n\)) delete operations be performed in an arbitrary order on an empty queue Q.
    Let x and y be the number of push and pop operations performed respectively in the process.
    Which one of the following is true for all m and n?

  \begin{choices}
    \CorrectChoice  n+m \(<=\) x \(<\) 2n and 2m \(<=\) y \(<=\) n+m
    \choice         n+m \(<=\) x \(<\) 2n and 2m \(<=\) y \(<=\) 2n
    \choice         2m \(<=\) x \(<\) 2n and 2m \(<=\) y \(<=\) n+m
    \choice         2m \(<=\) x \(<\) 2n and 2m \(<=\) y \(<=\) 2n
  \end{choices}
\end{questyle}


\begin{questyle}
  \question  Suppose you are given an implementation of a queue of integers. The operations that can be performed on the queue are:
            isEmpty(Q), delete(Q), insert(Q, i)  (GATE-2007)

            \lstinputlisting[language=Octave]{./queue_code/queue_02.c}

  \begin{choices}
    \choice         Leaves the queue Q unchanged
    \CorrectChoice  Reverses the order of the elements in the queue Q
    \choice         Deletes front element  and inserts it at the rear keeping the other elements in the same order.
    \choice         Empties the queue Q
  \end{choices}
\end{questyle}

\begin{questyle}
  \question  Let Q denote a queue containing sixteen numbers and S be an empty stack. Head(Q) returns
            the element at the head of the queue Q without removing it from Q. Similarly Top(S) returns
            the element at the top of S without removing it from S. Consider the algorithm given below.
            The maximum possible number of iterations of the while loop in the algorithm is \fillin[256]   (GATE-2016\_set\_1)

          \lstinputlisting[language=Octave]{./queue_code/queue_03.c}
  Hint:
  \begin{enumerate}
    \item Loop terminates when Queue is empty.
    \item Once smallest element of queue goes into Stack, it never comes out.
    \item When queue is sorted in increasing order. Queue is copied to Stack and while-loop come to end.
    \item Worst case: queue is sorted in decreasing order.
    \item T(n) = 2(n-1) + 1 = 2n - 1
    \item After T(n) iteration, smallest element of Queue is pushed on to the Stack. Elements in Queue reduces by 1.
    \item Stack stores smallest element one over the other. Eventually Q is empty.
    \item This is a sorting algorithm.
  \end{enumerate}

\end{questyle}

